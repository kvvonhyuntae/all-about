# Numpy-7 / 다차원 배열 다루기 2
## 1. 슬라이싱
- Numpy 배열은 다차원인 경우가 많기 때문에 각 차원별로 어떻게 슬라이스 할건지 정확히 표현해야한다.
- Numpy 배열을 슬라이싱하면, 연속된 값을 가져오기에 결과로 얻어지는 배열은 언제나 원본 배열의 부분배열이다.

```python
a[:,:] // 시작 값부터 끝 값 전 까지 슬라이싱
```
- <span style="color:orange"> a [행 슬라이싱 시작:행 슬라이싱 끝, 열 슬라이싱 시작:열 슬라이싱 끝]
- 슬라이싱에서 시작 값은 포함이지만 끝 값은 포함하지 않는다.  *경게를 잘볼것* 
- 시작값이 0인 경우 생략이 가능하며 끝값이 shape의 값과 동일한 경우 생략 가능하다.
- 열을 슬라이싱 하지 않을 경우 열부분은 전체 생략 가능하다. 반대로 행은 슬라이싱 하지 않는다고 해도 생략할 수 없다.
```python
a[:2] // 열부분을 생략할 경우의 코드
```
<br>**실수를 방지하기위해 슬라이싱에 익숙해지기 전까지는 생략하지 않는 것이 좋다.**</br>

## 2. 인덱싱
- 슬라이싱은 해당 부분을 잘라내는 것이라면 인덱싱은 원하는 요소를 선택해서 가져오는 것
- 인덱싱을 통해 원소에 접근할 수 있다.
- 슬라이싱은 ':'을 사용해서 구뷴하고, 인덱싱은 ','을 사용해서 구분한다.
- 첫번째 것을 더 많이 사용함
```python
1. a[0,0]
2. a[0][0]
```
<span style="color:orange"><br>*Numpy배열을 슬라이싱하면 연속된 값을 가져오기에 
결과로 얻어지는 값은 항상 원본 배열의 부분배열이다.
하지만 인덱싱을 한다면 연속하지 않은 값을 가져올 수 있으니 
원본과 다른 배열을 만들 수 있다.*</br>

### 1)인덱싱 & 슬라이싱 - 차원
행을 예시로 들 경우
- 슬라이싱만 사용했을때는 원본을 잘라서 가져오는것이기때문에 차원은 그대로 유지된다.
- 다만 인덱싱과 섞어서 사용할경우 차원이 줄어들 수 있다.

다차원 배열 간 연산에서 차원이 달라 문제가 발생하는 경우가 종종 있음
<br>**따라서 특별히 인덱싱을 사용해야하는 상황이 아니라면 인덱싱보다 슬라이싱을 추천한다.**</br>

### 2)인덱싱&슬라이싱 -값 복사&참조
인덱싱은 값을 복사해오기 때문에 복사된 값을 변경해도 원본의 값은 변하지 않음
```python
#인덱싱해서_b에_대입
b = a[0,0]
#b_값_수정
b = 100

print("a[0,0]":{}.format(a[0,0]))
print("b:{}".format(b))
```

슬라이싱한 배열은 원본 배열과 같은 데이터를 참조한다.
<br><span style="color:orange">따라서 슬라이싱된 배열을 수정하면 원본 배열 역시 수정된다.</span></br>

```python
#a를  슬라이스 하여 C 생성
c = a[1:3, 1:3]
print(c)
```
````python
#c[0,0]dms a[]1.,1과 같은 데이터이다.
c[0, 0] = 100
print(c)
print('----------')
print(a)
````
### 3)불리언 배열 인덱싱
특정한 조건을 만족하는 요소만 선택하고자 할 때 사용된다.

```python
bool_idx = (a > 2) #2보다 큰 a의 요소를 찾는다
                   #이 코드는 a와 shape가 같고 불리언 자료형을 요소로하는 numpy 배열을 반환한다
                   #bool_idx의 각 요소는 동일한 위치에 있는 a의
                   #요소가 2보다 큰지를 말해준다.
print(bool_idx) #출력 "[[False False]]
                #     [[True True]]
                #     [[True True]]"
#불리언 배열 인덱싱을 통해 bool_idx에서
#참값을 가지는 요소로 구성되는
#rank 2인 배열을 구성할 수 있다.
print(a[bool_idx]) #출력"[3 4 5 6]"

#위에서 한 모든것을 한 문장으로 할 수 있다
print(a[a > 2])
```
판다스, 데이터 필터링 등 여러 곳에서 많이 쓰이니 잘 알아둘것

## (참조) 정수 배열 인덱싱
```python
#정수 배열 인덱싱의 예
#반환되는 배열의 shape는 (3,)
print(a[[0,1,2],[0,1,0]]) #출력 "[1 4 5]
#각 [0,1,2]는 X 좌표의 역할을 [0,1,0]은 y 좌표의 역할을 한다.

#위의 정수 배열은 아래와 같다.
print(np.array([a[0,0], a[1,1], a[2,0]])) #출력 "[1,4,5]"

#정수 배열 인덱싱을 사용할 때, 원본  배열의 같은 요소를 재선택할 수 있다.
print(a[[0,0], [1,1]]) #출력 "[2 2]"

#위의 에제는 아래와 같음
print(np.array([a[0,1], a[0,1]])) #출력"[2 2]"
```
## 3. 전치(Transpose)
행렬의 주 대각선을 기준으로 대칭되는 요소끼리 바꾸는것을 의미한다. 끝에 *" .T "*를 붙여준다
머신러닝 할때 주로 사용하며 <span style="color:orange"><br> *차원이 1일경우 transpose를 실향해도 아무런 변화가 없다.* </br></span>
```python
import numpy as np
X = np.array([[1,2], [3,4]])
print(X) #출력"[[1 2]
         #    [3 4]]"
print(X.T) #출력 "[[1 3]
           #     [2 4]]"
```